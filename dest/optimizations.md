# 33.6\. 优化

大部分shell脚本在处理不太复杂的问题的时候, 使用的都是小吃店(快速但是并不优雅)的方式. 正因为这样, 所以优化脚本的速度并不是一个大问题. 考虑一下这种情况, 当脚本正在处理一个重要任务的时候, 虽然这个脚本能够处理的很好, 但是它运行的速度实在太慢. 在这种情况下, 使用编译语言重写它其实也不是一种很合适的办法. 最简单的办法其实就是重写这个脚本执行效率低下的部分. 那么, 是否这种办法可以成为处理效率低下的shell脚本的一种原则?

仔细检查脚本中循环的部分. 因为重复的操作非常耗时. 如果有可能的话, 尽量删除掉循环中比较耗时的操作.

优先使用[内建命令](internal.md#BUILTINREF), 而不是系统命令. 这是因为内建命令执行得更快, 并且在调用时, 一般都不会产生子进程.

避免使用不必要的命令, 尤其是[管道](special-chars.md#PIPEREF)中的命令.

| 

<pre class="PROGRAMLISTING">  1 cat "$file" | grep "$word"
  2 
  3 grep "$word" "$file"
  4 
  5 #  上面的两行具有相同的效果, 
  6 #+ 但是第二行运行的更快, 因为它不产生子进程. </pre>

 |

[cat](basic.md#CATREF)命令看起来经常在脚本中被滥用.

使用[time](timedate.md#TIMREF)和[times](x6756.md#TIMESREF)工具来了解计算所消耗的时间. 可以考虑使用C语言, 甚至是汇编语言来重写时间消耗比较大的代码部分.

尝试尽量减少文件I/O的操作. 因为Bash在处理文件方面, 显得并不是很有效率, 所以可以在脚本中考虑使用更合适的工具, 比如[awk](awk.md#AWKREF)或[Perl](wrapper.md#PERLREF).

使用结构化的思想来编写脚本, 并且按照需求将各个模块组织并紧密结合起来. 一些适用于高级语言的优化技术也可以用在脚本上, 但是有些技术, 比如, 循环展开优化(loop unrolling), 就根本用不上. 关于上面的讨论, 可以根据经验来取舍.

怎么才能很好的减少脚本的执行时间, 让我们看一个优秀的例子, [例子 12-42](mathc.md#MONTHLYPMT).